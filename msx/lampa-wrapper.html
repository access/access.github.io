<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, viewport-fit=cover" />
  <title>Lampa Wrapper</title>

  <!--
    Принцип:
    - НИЧЕГО не “пересобираем” и не ломаем пути Лампы.
    - Ставим <base href="UPSTREAM"> чтобы ./vender/... работали.
    - Грузим app.min.js как blob и запускаем.
    - Подменяем plugins_black_list.json на свой список (fetch + XHR).
    - Guard history.pushState (чужой origin -> hash).
    - SAFE-LOADER для внешних plugin scripts: грузим текстом, оборачиваем в try/catch.
    - Фокус/keydown для пульта.
  -->

  <link rel="stylesheet" href="https://yumata.github.io/lampa/css/app.css">
  <link rel="stylesheet" href="https://yumata.github.io/lampa/vender/scrollbar/jquery.scrollbar.css">
  <link rel="stylesheet" href="https://yumata.github.io/lampa/vender/keypad/style.css">

  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: #000;
      overflow: hidden;
    }

    /* Оверлей логов */
    #__log {
      position: fixed;
      right: 8px;
      bottom: 8px;
      width: calc(100% - 16px);
      height: 30%;
      overflow: auto;
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(0,0,0,0.45);
      color: rgba(255,255,255,0.92);
      font: 8px/1.25 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      z-index: 2147483647;
      pointer-events: none;
      white-space: pre-wrap;
      word-break: break-word;
      -webkit-font-smoothing: antialiased;
    }
    #__log .e { color: #ffb4b4; }
    #__log .w { color: #ffe6a6; }
    #__log .ok { color: #b9ffb9; }
    #__log .dim { opacity: 0.75; }

    body { outline: none; }
  </style>
</head>

<body tabindex="0">
  <div id="__log"></div>

  <script>
  (function () {
    'use strict';

    // === CONFIG ===============================================================

    const UPSTREAM = 'https://yumata.github.io/lampa/';
    const VENDER   = UPSTREAM + 'vender/';
    const APP_URL  = 'https://raw.githubusercontent.com/yumata/lampa/main/app.min.js';

    const VENDORS = [
      // (опционально, но пусть будет: webOS API)
      { name: 'webOSTV',   url: 'https://yumata.github.io/lampa/webos/webOSTV.js' },

      // базовые зависимости
      { name: 'jquery',    url: VENDER + 'jquery/jquery.js' },
      { name: 'notify',    url: VENDER + 'notify/notify.js' },
      { name: 'scrollbar', url: VENDER + 'scrollbar/jquery.scrollbar.js' },
      { name: 'navigator', url: VENDER + 'navigator/navigator.js' },
      { name: 'keypad',    url: VENDER + 'keypad/keypad.js' }
    ];

    // ТВОЙ black list (JSON array)
    const BLACKLIST = [
      'lampa.line.pm',
      'xabb.ru/h.js',
      'ebu.land',
      'abu.land',
      'lampa32.github.io/torrserver.js',
      'abmsx.tech/torrserver.js',
      'cxlampa.github.io/cub_off.js',
      'lampatv.fun',
      'xiaomishka.github.io/lampa/ads.js',
      'xiaomishka.github.io',
      'uspeh.sbs/app.js',
      'andreyurl54.github.io',
      'torrs.su',
      'uspeh.sbs/ss.js',
      'uspeh.sbs',
      'usph.xyz/aa.js',
      'lampa.land/plugins/r.js',
      'tvigl.info/plugins/shots.js',
      'lipp.xyz',
      'llpp.xyz',
      'scabrum.github.io',
      'bylampa.github.io',
      'tinyurl.com',
      't.me/',
      '4pda.',
      'teletype.in',
      'yotube.com'
    ];

    // SAFE-LOADER будет пытаться “обезвредить” любые внешние plugin-скрипты.
    // По умолчанию: всё что содержит "/plugin/" ИЛИ "/plugins/" грузим через try/catch.
    const SAFE_SCRIPT_MATCH = (urlStr) => {
      const s = String(urlStr || '');
      // только http(s)
      if (!/^https?:\/\//i.test(s)) return false;
      // безопасить в основном плагины (не core-скрипты Лампы)
      if (s.includes('/plugin/') || s.includes('/plugins/')) return true;
      return false;
    };

    // === LOG ==================================================================

    const elLog = document.getElementById('__log');

    function _ts() {
      const t = (performance.now() / 1000).toFixed(3);
      return t.padStart(7, ' ');
    }

    function log(msg, cls) {
      const line = document.createElement('div');
      if (cls) line.className = cls;
      line.textContent = `${_ts()} ${msg}`;
      elLog.appendChild(line);
      elLog.scrollTop = elLog.scrollHeight;
    }

    const ok   = (m) => log('[OK]  ' + m, 'ok');
    const warn = (m) => log('[WRN] ' + m, 'w');
    const err  = (m) => log('[ERR] ' + m, 'e');

    // === HELPERS ==============================================================

    function injectBaseHref(href) {
      // один раз
      if (document.querySelector('base[data-lampa-wrap="1"]')) return;
      const base = document.createElement('base');
      base.setAttribute('data-lampa-wrap', '1');
      base.href = href;
      document.head.insertBefore(base, document.head.firstChild);
    }

    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.async = false; // порядок
        s.onload = () => resolve();
        s.onerror = () => reject(new Error('Failed to load: ' + src));
        document.head.appendChild(s);
      });
    }

    async function fetchText(url) {
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`fetch failed ${res.status}: ${url}`);
      return await res.text();
    }

    function focusKick() {
      try { document.body.focus(); } catch {}
      try { window.focus(); } catch {}
    }

    function safeString(x) {
      try { return (x && x.message) ? x.message : String(x); } catch { return 'unknown'; }
    }

    // === PATCHES ==============================================================

    function patchHistoryCrossOriginGuard() {
      const origPush = history.pushState.bind(history);
      const origRepl = history.replaceState.bind(history);

      function safe(op, state, title, url) {
        try {
          if (typeof url === 'string' && url.length) {
            const u = new URL(url, location.href);
            if (u.origin !== location.origin) {
              const safeUrl =
                location.pathname +
                location.search +
                '#ext=' + encodeURIComponent(u.href);
              return op(state, title, safeUrl);
            }
          }
          return op(state, title, url);
        } catch (_) {
          // не даём падать
          return;
        }
      }

      history.pushState = function (state, title, url) { return safe(origPush, state, title, url); };
      history.replaceState = function (state, title, url) { return safe(origRepl, state, title, url); };
      ok('history.push/replaceState guarded');
    }

    function patchBlacklistInterceptors() {
      const json = JSON.stringify(BLACKLIST);

      const match = (u) => {
        try { return String(u || '').includes('plugins_black_list.json'); }
        catch { return false; }
      };

      // fetch()
      const origFetch = window.fetch ? window.fetch.bind(window) : null;
      if (origFetch) {
        window.fetch = async function (input, init) {
          const url = (typeof input === 'string')
            ? input
            : (input && input.url) ? input.url : '';

          if (match(url)) {
            ok('blacklist: served via fetch()');
            return new Response(json, {
              status: 200,
              headers: { 'Content-Type': 'application/json; charset=utf-8' }
            });
          }
          return origFetch(input, init);
        };
      }

      // XHR (jQuery.ajax тоже здесь)
      const XHR = window.XMLHttpRequest;
      if (XHR) {
        const origOpen = XHR.prototype.open;
        const origSend = XHR.prototype.send;

        XHR.prototype.open = function (method, url) {
          this.__lw_url = url;
          this.__lw_blk = match(url);
          return origOpen.apply(this, arguments);
        };

        XHR.prototype.send = function () {
          if (this.__lw_blk) {
            ok('blacklist: served via XHR');
            // эмулируем асинхронный ответ, чтобы Лампа не словила “синхронный” сюрприз
            const xhr = this;
            setTimeout(() => {
              try {
                // responseText/response часто read-only, но defineProperty обычно проходит на инстансе
                try { Object.defineProperty(xhr, 'responseText', { configurable: true, get: () => json }); } catch {}
                try { Object.defineProperty(xhr, 'response',     { configurable: true, get: () => json }); } catch {}
                try { Object.defineProperty(xhr, 'status',       { configurable: true, get: () => 200 }); } catch {}
                try { Object.defineProperty(xhr, 'readyState',   { configurable: true, get: () => 4 }); } catch {}
              } catch {}

              // колбэки
              try { xhr.onreadystatechange && xhr.onreadystatechange(); } catch {}
              try { xhr.onload && xhr.onload(); } catch {}
              try { xhr.dispatchEvent && xhr.dispatchEvent(new Event('load')); } catch {}
            }, 0);
            return;
          }
          return origSend.apply(this, arguments);
        };
      }

      ok('blacklist interceptors installed');
    }

    function patchSafeExternalScriptLoader() {
      // Цель: чтобы любые внешние plugin scripts не валили инициализацию,
      // если в них ошибка в момент выполнения (как у тебя с "shots: innerHTML").
      //
      // Реализация:
      // - перехватываем appendChild(script[src]) и вместо обычной загрузки:
      //   fetch -> wrap try/catch -> blob -> inject -> onload
      //
      // Важно: это НЕ “ловит” ошибки, которые произойдут через минуты по таймеру в плагине,
      // но решает твой конкретный класс “падает прямо при загрузке/инициализации плагина”.

      const _append = Node.prototype.appendChild;

      Node.prototype.appendChild = function (node) {
        try {
          if (node && node.tagName === 'SCRIPT') {
            const src = String(node.getAttribute('src') || node.src || '');
            if (src && SAFE_SCRIPT_MATCH(src)) {
              warn('SAFE-LOADER: ' + src);

              // не даём браузеру грузить как обычный <script src=...>
              // вместо этого — подхватываем сами:
              (async () => {
                try {
                  const code = await fetchText(src);

                  // wrap: try/catch вокруг всего тела
                  const wrapped =
                    "(()=>{try{\n" +
                    code +
                    "\n}catch(e){\n" +
                    "  console.error('[SAFE-PLUGIN] ' + " + JSON.stringify(src) + " + ' crashed:', e);\n" +
                    "}})();\n" +
                    "//# sourceURL=" + src.replace(/[\r\n]/g, '') + "\n";

                  const blob = new Blob([wrapped], { type: 'text/javascript' });
                  const blobUrl = URL.createObjectURL(blob);

                  const s = document.createElement('script');
                  s.async = false;
                  s.src = blobUrl;

                  s.onload = () => {
                    try { URL.revokeObjectURL(blobUrl); } catch {}
                    try { node.onload && node.onload(); } catch {}
                    try { node.dispatchEvent && node.dispatchEvent(new Event('load')); } catch {}
                  };

                  s.onerror = (e) => {
                    try { URL.revokeObjectURL(blobUrl); } catch {}
                    try { node.onerror && node.onerror(e); } catch {}
                  };

                  // ВАЖНО: вставляем туда же, где должен был быть оригинал
                  _append.call(this, s);
                } catch (e) {
                  console.error('[SAFE-PLUGIN] load failed:', src, e);
                  try { node.onerror && node.onerror(e); } catch {}
                }
              })();

              return node; // “как будто вставили”
            }
          }
        } catch (_) {
          // если патчер сам упал — не ломаем DOM
        }

        return _append.call(this, node);
      };

      ok('SAFE-LOADER installed (/plugin/ /plugins/)');
    }

    // === BOOT =================================================================

    async function boot() {
      log('[LOG] UA: ' + navigator.userAgent, 'dim');

      injectBaseHref(UPSTREAM);

      patchHistoryCrossOriginGuard();
      patchSafeExternalScriptLoader();

      window.lampa_settings = window.lampa_settings || {};

      // vendor'ы
      for (const v of VENDORS) {
        log('[LOG] load vendor: ' + v.url, 'dim');
        await loadScript(v.url);
        ok('loaded: ' + v.name);
      }

      patchBlacklistInterceptors();

      // app.min.js
      log('[LOG] fetch app.min.js: ' + APP_URL, 'dim');
      const code = await fetchText(APP_URL);

      log('[LOG] run app.min.js (blob)...', 'dim');
      const blob = new Blob([code], { type: 'text/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      await loadScript(blobUrl);
      try { URL.revokeObjectURL(blobUrl); } catch {}

      // TV режим
      if (window.Lampa && window.Lampa.Platform && typeof window.Lampa.Platform.tv === 'function') {
        try {
          window.Lampa.Platform.tv();
          ok('Lampa.Platform.tv() called');
        } catch (e) {
          warn('Lampa.Platform.tv() failed: ' + safeString(e));
        }
      }

      // фокус для пульта/keydown
      focusKick();
      setTimeout(focusKick, 250);
      setTimeout(focusKick, 1000);
      document.addEventListener('visibilitychange', focusKick, true);
      document.addEventListener('click', focusKick, true);

      ok('Lampa started');
    }

    // глобальные ловушки (чтобы wrapper сам не умирал + лог)
    window.addEventListener('error', (e) => {
      err(e && e.message ? e.message : safeString(e));
    });

    window.addEventListener('unhandledrejection', (e) => {
      err('Promise: ' + (e && e.reason ? safeString(e.reason) : 'unknown'));
    });

    boot().catch((e) => {
      err(e && e.message ? e.message : safeString(e));
    });

  })();
  </script>
</body>
</html>
